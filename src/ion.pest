WHITESPACE = _{ " " | "\t" }
Char = _{ 'a'..'z' | 'A'..'Z' }
Digit = _{ '0'..'9' }
Escaped = { "\\" ~ ANY }

// Variables can contain/start with '_' and/or ASCII characters
Ident = @{ Keyword ~ (Char | "_" | Digit)+
         | !Keyword ~ (Char | "_")+ ~ (Char | "_" | Digit)* }

// Line starting with '#' counts as comment until the end of the line
Comment = _{ "#"+ ~ ANY* }

// Statements separated by either ';' or '\n'
Sep = { SemiColon | NewLine }
  SemiColon = { ";" }
  NewLine   = { "\n" }

Keyword = _{ End
           | Let
	   | Export
	   | Match | Case
	   | If | ElseIf | Else
	   | And | Or
	   | For | In
	   | While
	   | Break | Continue
	   | Fn }
  End      = { "end" }
  Let      = { "let" }
  Export   = { "export" }
  Alias    = { "alias" }
  Match    = { "match" }
  Case     = { "case" }
  If       = { "if" }
  Else     = { "else" }
  ElseIf   = { "else if" }
  And      = { "and" | "&&" }
  Or       = { "or" | "||" }
  For      = { "for" }
  In       = { "in" }
  While    = { "while" }
  Break    = { "break" }
  Continue = { "continue" }
  Fn       = { "fn" }

// Literal parsing
// XXX: Do we need explicit signs or can be hiden with `_{}` matchin?
Sign = _{ SignNeg | SignPlus }
  SignPlus = ${ "+" | "" }
  SignNeg  = ${ "-" }

FloatHead = _{ Digit }
FloatFrac = _{ Digit }
FloatSep = _{ "." }

Literal = _{ LitFloat
           | LitInt
	   | LitBool
	   | LitStr
	   | LitArray
	   | LitMap
	   | Atom }
  LitFloat = ${ Sign ~ ( FloatHead* ~ FloatSep ~ FloatFrac+
                       | FloatHead+ ~ FloatSep ~ FloatFrac*) }
  LitInt = ${ Sign ~ Digit+ }
  LitBool = { False | True }
    False = _{ "false" }
    True  = _{ "true" }
  // XXX: LitChar should not be added to Literals directly, since they
  // are just used in special casing Range
  LitChar = { (Quote ~ Char ~ Quote) | Char }
  LitStr = _{ LitSQuoteStr
	    | LitDQuoteStr
	    | LitEvalStr }
    LitSQuoteStr = { SQuote ~ (Escaped | !SQuote ~ ANY)* ~ SQuote }
    LitDQuoteStr = { DQuote ~ (Escaped | !(DQuote | EvalOp) ~ ANY)* ~ DQuote }
    LitEvalStr   = { DQuote ~ ( Eval
			      | Method
			      | SubShell
			      | Escaped
			      | !DQuote ~ ANY )* ~ DQuote }
  LitArray = _{ LitRangeArray
              | LitFloatArray
	      | LitIntArray
	      | LitAnyArray }
    // XXX: Array from range is not supported ATM.
    LitRangeArray = { "[" ~ Range ~ "]" }
    LitFloatArray = { "[" ~ LitFloat+ ~ "]" }
    LitIntArray   = { "[" ~ LitInt+ ~ "]" }
    LitAnyArray   = { "[" ~ Literal* ~ "]" }
  LitMap = { "[" ~ LitMapPair+ ~ "]" }
    LitMapPair = ${ LitMapKey ~ "=" ~ LitMapValue }
      LitMapKey   = { IndexedEval | !ArrEvalOp ~ Pipeline }
      LitMapValue = { Pipeline }

// Range syntax
RangeOp = _{ (RangeIn | RangeEx) }
  RangeIn = { ("..." | "..=") }
  RangeEx = { ".." }
RangeVal  = _{ LitInt
             | LitChar
	     | (Sign? ~ ( StrMethod
	                | StrEval
			| IndexedEval
			| Shell
			| ReturnShell )) }

RangeStep = ${ ".." ~ (LitInt
                      | (Sign? ~ ( StrMethod
		                 | StrEval
				 | IndexedEval
				 | Shell
				 | ReturnShell ))) }

Range = { RangeVal ~ (RangeStep ~ RangeOp | RangeOp) ~ RangeVal }

// Redirection and pipe operators
PipelineOp = _{ WHITESPACE* ~
              ( PipeStdOut
              | PipeStdErr
	      | PipeBoth
	      | RedirStdOut
	      | RedirStdOutAppend
	      | RedirStdErr
	      | RedirBoth ) ~ WHITESPACE* }
  PipeStdOut        = ${"|"}
  PipeStdErr        = ${"^|"}
  PipeBoth          = ${"&|"}
  RedirStdOut       = ${">"}
  RedirStdOutAppend = ${">>"}
  RedirStdErr       = ${"^>"}
  RedirBoth         = ${"&>"}

Pipeline = { Expression+ ~ (PipelineOp ~ Expression+)* }

SubShell = _{ Shell | ArrayShell | ReturnShell }
  Shell       = ${"$(" ~ (WHITESPACE | Pipeline)* ~ ")"}
  ArrayShell  = ${"@(" ~ (WHITESPACE | Pipeline)* ~ ")"}
  // XXX: Directly getting the return code from subshell is not supported ATM.
  ReturnShell = ${"?(" ~ (WHITESPACE | Pipeline)* ~ ")"}

// Variable syntax consist of variable name with optional ':' separated type
// specifier, example would be 'varname:type'.
// A variable can also be indexed, when a value is re-assigned for an
// array or map, but in thet case if cannot be typed.

Variable = @{ Ident ~ (":" ~ Type | Indexed+ )? }
  Indexed = ${ "[" ~ !ArrEvalOp ~ (Range | LitMapKey) ~ "]" }
  Type = _{ Primitive | AnyArray | TypedArray | Map }
    Primitive = _{ Bool | Int | Float | Str }
      Bool  = { "bool" }
      Int   = { "int" }
      Float = { "float" }
      Str   = { "str" }
    TypedArray = { "[" ~ Type ~ "]" }
    AnyArray = { "[]" }
    Map = _{ BMap | HMap }
      BMap = ${ "bmap" ~ TypedArray }
      HMap = ${ "hmap" ~ TypedArray }

// Multiple variable bindings can be declared on the same line, where
// each 'varname:type' is whitespace separated
Variables = { Variable ~ Variable* }

// Assignment
AssignOp = _{ Assign
            | IncAssign
	    | DecAssign
	    | MulAssign
	    | DivAssign
	    | AppendAssign
	    | PrependAssign}
  Assign        = { "=" }
  IncAssign     = { "+=" }
  DecAssign     = { "-=" }
  MulAssign     = { "*=" }
  DivAssign     = { "/=" }
  AppendAssign  = { "++=" }
  PrependAssign = { "::=" }

EvalOp = _{ ArrEvalOp | StrEvalOp }
  ArrEvalOp = _{ "@" }
  StrEvalOp = _{ "$" }

Quote = _{ SQuote | DQuote }
  SQuote = { "'" }
  DQuote = { "\"" }

Parent = _{ "(" | ")" }
Brace  = _{ "{" | "}" }
Bracket = _{ "[" | "]" }

AtomShouldntMatch = _{ WHITESPACE | Sep | EvalOp | SQuote | DQuote | PipelineOp
                     | "(" | ")" | "{" | "}" | "[" | "]" | "#" }

Atom = @{ Keyword ~ (!AtomShouldntMatch ~ ANY)+
        | !Keyword ~ (!AtomShouldntMatch ~ ANY)+ }

Eval = _{ StrEval | IndexedEval | ArrEval }
  StrEval     = ${ StrEvalOp ~ Ident }
  ArrEval     = ${ ArrEvalOp ~ Ident }
  IndexedEval = ${ ArrEval ~ Indexed+ }

// XXX: Assuming methods have at least one argument
Method = _{ StrMethod | ArrMethod }
  StrMethod = ${ StrEvalOp ~ Ident ~ "(" ~ MethodArgs ~ ")" }
  ArrMethod = ${ ArrEvalOp ~ Ident ~ "(" ~ MethodArgs ~ ")" }
    MethodArgs = _{ Expression ~ (WHITESPACE ~ Expression)* }

Expression = _{ Method
              | Eval
	      | SubShell
	      | Literal }

StatementLet = { Let ~ Variables ~ AssignOp ~ Expression+ }

Statements = _{ StatementLet ~ Comment? }
Pipelines = _{ Pipeline ~ Comment? }

Input = { Comment | Statements | Pipelines }

Main = { SOI ~ Input ~ Sep? ~ EOI }
